#![allow(static_mut_refs)]
use crate::{
	maps::{FILE, FILES_STRUCT, PIDS, TASK_STRUCT, TCP_SOCK},
	vmlinux::{file, files_struct, socket, task_struct, tcp_sock},
};
use aya_ebpf::helpers::{
	bpf_get_current_pid_tgid, bpf_probe_read as bpf_helper_read,
	gen::{bpf_get_current_task, bpf_probe_read, bpf_probe_read_kernel},
};
use mercury_common::Quintuple;

/// Check if the pid is in pid_map, which is generated by agent at user space
#[inline]
pub(crate) fn is_filtered_pid() -> bool {
	let tgid = (bpf_get_current_pid_tgid() >> 32) as u32;
	unsafe { PIDS.get_ptr(&tgid) }.is_some()
}
// TODO: use too much stack memory, need to optimize
#[inline]
pub(crate) fn tcp_sock_from_fd(fd: u64) -> Result<*const tcp_sock, u32> {
	let current_task = unsafe { bpf_get_current_task() } as *const task_struct;
	let task = unsafe { TASK_STRUCT.get_ptr_mut(0) }.ok_or(0_u32)?;
	if unsafe {
		bpf_probe_read_kernel(
			task as *mut _,
			size_of::<task_struct>() as u32,
			current_task as *const _,
		)
	} != 0
	{
		return Err(0);
	}

	let files = unsafe { FILES_STRUCT.get_ptr_mut(0) }.ok_or(0_u32)?;
	if unsafe {
		bpf_probe_read(files as *mut _, size_of::<files_struct>() as u32, (*task).files as *const _)
	} != 0
	{
		return Err(0_u32);
	}

	let fd_table = unsafe { bpf_helper_read((*files).fdt) }.map_err(|_| 0u32)?;
	let max_fds = fd_table.max_fds;

	if fd as u32 > max_fds {
		return Err(1_u32);
	}

	let file_ptr = unsafe { bpf_helper_read(fd_table.fd.add(fd as usize)) }.map_err(|_| 0u32)?;

	let file = unsafe { FILE.get_ptr_mut(0) }.ok_or(0_u32)?;
	if unsafe {
		bpf_probe_read_kernel(file as *mut _, size_of::<file>() as u32, file_ptr as *const _)
	} != 0
	{
		return Err(0_u32);
	}

	let socket =
		unsafe { bpf_helper_read((*file).private_data as *const socket) }.map_err(|_| 1u32)?;

	if socket.type_ != 1 && socket.type_ != 2 {
		return Err(0_u32);
	}

	let tcp_sock: *mut tcp_sock = unsafe { TCP_SOCK.get_ptr_mut(0) }.ok_or(0_u32)?;
	if unsafe {
		bpf_probe_read(tcp_sock as *mut _, size_of::<tcp_sock>() as u32, socket.sk as *const _)
	} != 0
	{
		return Err(0_u32);
	}

	Ok(tcp_sock)
}

pub(crate) fn read_seq(fd: u64) -> Result<u32, u32> {
	let sock = tcp_sock_from_fd(fd)?;
	Ok(unsafe { &*sock }.copied_seq)
}

pub(crate) fn write_seq(fd: u64) -> Result<u32, u32> {
	let sock = tcp_sock_from_fd(fd)?;
	Ok(unsafe { &*sock }.write_seq)
}

pub fn quintuple_from_sock(tcp_sock: *const tcp_sock) -> Quintuple {
	let src_addr = unsafe { &*tcp_sock }.inet_conn.icsk_inet.inet_saddr.to_be();
	let dst_addr =
		unsafe { (*tcp_sock).inet_conn.icsk_inet.sk.__sk_common.__bindgen_anon_1.__bindgen_anon_1 }
			.skc_daddr
			.to_be();
	let src_port = unsafe { &*tcp_sock }.inet_conn.icsk_inet.inet_sport.to_be();
	let dst_port =
		unsafe { (*tcp_sock).inet_conn.icsk_inet.sk.__sk_common.__bindgen_anon_3.__bindgen_anon_1 }
			.skc_dport
			.to_be();
	let skc_family = unsafe { &*tcp_sock }.inet_conn.icsk_inet.sk.__sk_common.skc_family;
	Quintuple::new(src_addr, dst_addr, src_port, dst_port, skc_family)
}
