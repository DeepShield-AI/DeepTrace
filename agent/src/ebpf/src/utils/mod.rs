#![allow(static_mut_refs)]
#[cfg(test)]
pub(crate) mod tests;

use crate::{
	maps::{FD_TABLE, FILE, FILES_STRUCT, PIDS, SOCKET, TASK_STRUCT, TCP_SOCK},
	vmlinux::{fdtable, file, files_struct, socket, task_struct, tcp_sock},
};
use aya_ebpf::{
	bindings::{BPF_TCP_CLOSE_WAIT, BPF_TCP_ESTABLISHED},
	helpers::{
		bpf_get_current_comm, bpf_get_current_pid_tgid, bpf_probe_read as bpf_helper_read,
		gen::{bpf_get_current_task, bpf_probe_read},
	},
};
use mercury_common::{
	protocols::{L4Protocol, ProtocolFamily},
	socket::SocketType,
	structs::Quintuple,
};

/// Check if the pid is in pid_map, which is generated by agent at user space
#[inline]
pub(crate) fn is_filtered_pid() -> bool {
	let tgid = (bpf_get_current_pid_tgid() >> 32) as u32;
	unsafe { PIDS.get_ptr(&tgid) }.is_some()
}

#[inline]
pub(crate) fn is_tcp_udp(sock: *const tcp_sock) -> Result<L4Protocol, u32> {
	let ipv6only = unsafe { &*sock }.inet_conn.icsk_inet.sk.__sk_common.skc_ipv6only();
	let skc_family =
		ProtocolFamily::from(unsafe { &*sock }.inet_conn.icsk_inet.sk.__sk_common.skc_family);
	match skc_family {
		ProtocolFamily::PF_INET if ipv6only == 0 => {},
		// TODO: add ipv4_maped_to_ipv6 check
		ProtocolFamily::PF_INET6 => {},
		_ => return Err(0),
	}
	let sk_type = SocketType::from(unsafe { &*sock }.inet_conn.icsk_inet.sk.sk_type);
	match sk_type {
		SocketType::SOCK_DGRAM => return Ok(L4Protocol::IPPROTO_UDP),
		SocketType::SOCK_STREAM => {
			let skc_state = unsafe { &*sock }.inet_conn.icsk_inet.sk.__sk_common.skc_state as u32;
			// If the connection has not been established yet, and it is not in the `ESTABLISHED` or `CLOSE_WAIT` state, exit.
			if skc_state != BPF_TCP_ESTABLISHED && skc_state != BPF_TCP_CLOSE_WAIT {
				return Err(0);
			}
			return Ok(L4Protocol::IPPROTO_TCP);
		},
		_ => return Err(0),
	}
}

pub(crate) fn is_filtered_comm() -> bool {
	bpf_get_current_comm().is_ok_and(|comm| {
		&comm[..4] == b"ssh\0" || &comm[..4] == b"scp\0" || &comm[..5] == b"sshd\0"
	})
}

pub(crate) fn gen_connect_key(high: u64, low: u64) -> u64 {
	(high & 0xFFFFFFFF00000000) | (low & 0x00000000FFFFFFFF)
}

pub(crate) fn tcp_sock_from_fd(fd: u64) -> Result<usize, u32> {
	unsafe { tcp_sock_from_fd_inner(fd) }
}

#[inline]
unsafe fn tcp_sock_from_fd_inner(fd: u64) -> Result<usize, u32> {
	let task = TASK_STRUCT.get_ptr_mut(0).ok_or(0_u32)?;
	if bpf_probe_read(
		task as *mut _,
		size_of::<task_struct>() as u32,
		bpf_get_current_task() as *const _,
	) != 0
	{
		return Err(0);
	}

	let files = FILES_STRUCT.get_ptr_mut(0).ok_or(0_u32)?;
	if bpf_probe_read(files as *mut _, size_of::<files_struct>() as u32, (*task).files as *const _) !=
		0
	{
		return Err(0);
	}

	let fd_table = FD_TABLE.get_ptr_mut(0).ok_or(0_u32)?;
	if bpf_probe_read(fd_table as *mut _, size_of::<fdtable>() as u32, (*files).fdt as *const _) !=
		0
	{
		return Err(0);
	}

	let max_fds = (*fd_table).max_fds;

	if fd as u32 > max_fds {
		return Err(0);
	}
	// TODO: remove this function. Use bpf_probe_read instead
	let file_ptr = bpf_helper_read((*fd_table).fd.add(fd as usize)).map_err(|_| 0u32)?;

	let file = FILE.get_ptr_mut(0).ok_or(0_u32)?;
	if bpf_probe_read(file as *mut _, size_of::<file>() as u32, file_ptr as *const _) != 0 {
		return Err(0_u32);
	}
	let socket = SOCKET.get_ptr_mut(0).ok_or(0_u32)?;
	if bpf_probe_read(
		socket as *mut _,
		size_of::<socket>() as u32,
		(*file).private_data as *const _,
	) != 0
	{
		return Err(0);
	}
	let type_ = SocketType::from((*socket).type_ as u16);
	if type_ != SocketType::SOCK_STREAM && type_ != SocketType::SOCK_DGRAM {
		return Err(0_u32);
	}
	// TODO: add check logic here.

	let tcp_sock = TCP_SOCK.get_ptr_mut(0).ok_or(0_u32)?;
	if bpf_probe_read(tcp_sock as *mut _, size_of::<tcp_sock>() as u32, (*socket).sk as *const _) !=
		0
	{
		return Err(0_u32);
	}

	Ok(tcp_sock.addr())
}

pub(crate) fn read_seq(fd: u64) -> Result<u32, u32> {
	let sock = tcp_sock_from_fd(fd)?;
	Ok(unsafe { &*(sock as *const tcp_sock) }.copied_seq)
}

pub(crate) fn write_seq(fd: u64) -> Result<u32, u32> {
	let sock = tcp_sock_from_fd(fd)?;
	Ok(unsafe { &*(sock as *const tcp_sock) }.write_seq)
}

pub fn quintuple_from_sock(tcp_sock: *const tcp_sock) -> Quintuple {
	let src_addr = unsafe { &*tcp_sock }.inet_conn.icsk_inet.inet_saddr.to_be();
	let dst_addr =
		unsafe { (*tcp_sock).inet_conn.icsk_inet.sk.__sk_common.__bindgen_anon_1.__bindgen_anon_1 }
			.skc_daddr
			.to_be();
	let src_port = unsafe { &*tcp_sock }.inet_conn.icsk_inet.inet_sport.to_be();
	let dst_port =
		unsafe { (*tcp_sock).inet_conn.icsk_inet.sk.__sk_common.__bindgen_anon_3.__bindgen_anon_1 }
			.skc_dport
			.to_be();
	let skc_family = unsafe { &*tcp_sock }.inet_conn.icsk_inet.sk.__sk_common.skc_family;
	Quintuple::new(src_addr, dst_addr, src_port, dst_port, skc_family)
}
